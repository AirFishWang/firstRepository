UML类图6种关系: 依赖、关联、聚合、组合、继承、实现  （耦合程度从左到右一次增强）
    参考: http://www.cnblogs.com/justkong/p/4009475.html
    （1）依赖:就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A。class Book{}  class PeoPle{void read(Book book)}
    （2）关联:于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。
         class Father{private: Son son}  class Son{private: Father father}
    （3）聚合:C1聚合C2，但是C2可以离开C1而独立存在（独立存在的意思是在某个应用的问题域中这个类的存在有意义） 例如人有车和房子，车和房子离开人同样具有意义
    （4）组合: 强聚合，部分离开整体就基本无什么意义，例如人的灵魂与身体
    （5）继承: 子类，父类
    （6）实现: 接口


学习设计模式所需要思考的问题：
    （1）为什么要这么设计，这么设计能够解决哪些问题
    （2）这么设计，还存在哪些方面的不足

设计模式的常见7种原则
    （1）单一职责原则:  一个类只负责一个功能领域中的相应职责 
    （2）开闭原则:      软件实体应对扩展开放，而对修改关闭
    （3）里氏代换原则:  所有引用基类对象的地方能够透明地使用其子类的对象
    （4）依赖倒转原则:  抽象不应该依赖于细节，细节应该依赖于抽象(即应该面向接口编程，而不是针对实现编程)
    （5）接口隔离原则:  使用多个专门的接口，而不使用单一的总接口
    （6）合成复用原则:  尽量使用对象组合，而不是继承来达到复用的目的(区分Is-a和Has-a的关系)
    （7）迪米特法则；   一个软件实体应当尽可能少地与其他实体发生相互作用
    博客地址: http://blog.csdn.net/lovelion/article/details/17517213
    
    
1. 简单工厂模式
    将对象的创建与使用分离，防止在客户程序中大量创建对象的代码冗余(例如代码中多处需要依据type创建各种不同的对象，很多if-else)
    缺点: 
    （1）当类比较多的时候，简单工厂类就会显得冗长
    （2）当扩展新的类别的时候，必须修改简单工厂类的代码，违背了开闭原则
2. 工厂方法模式
    声明一个抽象的工作基类，针对每一个产品类，对应的声明一个工厂类(并继承工厂基类)，客户程序根据需要new出不同的工厂，并通过该工厂创建产品对象。
    当需要扩展新的产品类别的时候，只需要添加新的工厂类并继承工厂基类，而不需要修改原来的代码，克服了简单工厂模式的第二个缺点。
    缺点: 每一个类都对应一个工厂，增加了系统的复杂度
3. 抽象工厂模式:
    将具有相同特点的工厂类抽象出来，由子类具体实现
    
4. 单例模式
    确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。
    http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/ 
    
5. 原型模式
    用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象
    工作原理：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程
    注意深拷贝和浅拷贝的问题，如果需要深拷贝则需要通过java的序列化来实现
    
6. 建造者模式
    创建复杂的组合对象
    
7. 适配器模式
    将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。
    应用场景举例: 系统A声明了一个函数接口sort用于排序，现在手头有一个无源代码的算法库dll，其中的排序函数接口是quickSort，如果在不修改现有代码下，使系统能够使用算法库的排序函数

8. 桥接模式           
    处理多维度变化，如果软件系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使两者可以独立扩展，让系统更加符合“单一职责原则”。
    与多层继承方案不同，它将两个独立变化的维度设计为两个独立的继承等级结构，并且在抽象层建立一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。
   事例: 毛笔和蜡笔。假如我们需要大中小3种型号的画笔，能够绘制12种不同的颜色，如果使用蜡笔，需要准备3×12 = 36支，但如果使用毛笔的话，只需要提供3种型号的毛笔，
   外加12个颜料盒即可，涉及到的对象个数仅为 3 + 12 = 15，远小于36，却能实现与36支蜡笔同样的功能。如果增加一种新型号的画笔，并且也需要具有12种颜色，对应的蜡笔
   需增加12支，而毛笔只需增加一支。
   
9. 组合模式
    参考: http://www.cnblogs.com/chenssy/p/3299719.html
    组合模式定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。
    关键: 叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。
    事例: 操作系统的文件夹浏览问题
    
10. 装饰模式
    装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。
    动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。
    
11. 外观模式
    为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
    例如：不知道大家有没有比较过自己泡茶和去茶馆喝茶的区别，如果是自己泡茶需要自行准备茶叶、茶具和开水，如图1(A)所示，而去茶馆喝茶，最简单的方式就是跟茶馆服务员
    说想要一杯什么样的茶，是铁观音、碧螺春还是西湖龙井？正因为茶馆有服务员，顾客无须直接和茶叶、茶具、开水等交互，整个泡茶过程由服务员来完成，顾客只需与服务员交互即可，整个过程非常简单省事

12. 代理模式
    代理模式是常用的结构型设计模式之一，当无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，
    所访问的真实对象与代理对象需要实现相同的接口。
    
13. 迭代器模式
    迭代器模式(Iterator Pattern)：提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。
    
14. 观察者模式
    观察者想要获得信息，必须向消息发送者注册，当消息发送者需要发送消息时，会调用注册列表中的对象的相关方法
   
   
    
    
    
    
    
    