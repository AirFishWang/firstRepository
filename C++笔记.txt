(1)volatile   遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 
              当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存.
(2)mutable    被mutable修饰的变量可以在常成员函数中被修改
(3)const_cast 可以去除变量的volatitle属性和const属性，使用const_cast去除const限定的目的绝对不是为了修改它的内容，只是出于无奈
(4)sizeof     在编译时进行运算，与运行时无关
(5)左值       左值一定是可以寻址的，不能寻址的表达式不能作为左值，例如字面值常量
(6)unicode与utf8   Unicode是一种字符集(即字符的集合，国际标准，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储)，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。
              http://blog.jobbole.com/76376/
(7)explicit   指定构造器只能被明确调用，而不能隐式调用( 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 
              1 是个构造器 2 是个默认且隐含的类型转换操作符。 所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 
              这时候编译器就自动调用这个构造器， 创建一个AAA的对象。)
(8)struct与class struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的
                struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。
(9)reinterpret_cast  使任何类型的指针之间都可以互相转换，都不会得到编译错误， 
                    错误的使用reinterpret_cast很容易导致程序的不安全，只有将转换后的类型值转换回到其原始类型，这样才是正确使用reinterpret_cast方式。    

(10)类的定义后为什么要加分号？ 类在C++中被当着一种数据类型，但凡是跟在数据类型后面的不是变量就是函数，如果没有加分号，则会将后面的内容解释成变量或函数，导致出错。 
(11)类中的常成员变量和引用变量必须通过初始化列表来初始化，因为常变量和引用不能被赋值    
(12)类的静态成员变量的初始化问题, C++认为类体中的相关语句是变量的声明而不是定义，一般情况下不允许在类体中指定变量的值
        常静态成员变量(static const): 可在类中初始化，也可在类外初始化
            class A{
                static const int i;
                static const int j = 6;  //这里的右值必须是常量表达式
            };
            const int A::i = 5;     //这里的const不能省略, 不能有static关键字
        普通静态成员变量: 只能放在类外进行
            class B{
                static int i;
            };
            int B::i = 2; 
(13)为什么基类的析构函数是虚函数？ 在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。
                                    当基类指针指向派生类时，delete 基类指针，如果析构函数不是虚的，则只会调用基类的析构函数
(14)为什么复制构造函数的形参必须是一个引用？ 如果你给它定义的参数，是一个类型，而不是一个类型的引用，会导致无穷递归。 
(15)如果需要"深拷贝",必须显式的定义复制构造函数。
(16)new & operator new & placement new:
    new: 运算符， 申请内存和初始化对象
    operator new: 函数，类似于C语言的malloc，用于分配内存空间，但不会初始化空间，可以被重载
    placement new: 函数，定位放置new, A *p = new(ptr)A  ptr是指定的内存首地址
(17)如何禁止在堆和栈上创建对象？ 参考 http://www.cnblogs.com/vincently/p/4838283.html
    类的对象建立方式:
        静态建立: A a, 静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数
        动态建立: A* ptr=new A 第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。
    禁止在堆上建立对象:  将operator new()设为私有即可
    禁止在栈上建立对象:  编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。
                         如果类的析构函数是私有的或者保护的，则编译器不会在栈空间上为类对象分配内存(无法通过编译)。在堆上创建不会受到禁止
                         因此可以将析构函数设置成保护的，通过new来在堆上创建对象，但是由于析构函数是保护的，无法直接delete，所以需要提供一个共有的函数接口在对象使用完毕后来释放对象
                        更好的做法，是将构造函数和析构函数均设置为protected的，然后提供公有接口来返回对象实例。 
                        
(18)内存池技术    解决内存碎片，提高内存使用效率 http://blog.csdn.net/K346K346/article/details/49538975
(19)私有成员会被继承吗？  基类的私有成员在派生类中是"不可见"，这种不可见性指派生类的成员函数或者派生类的对象不能直接访问它们，但是却可以间接访问到它们   
(20)结构体对齐问题 
                    1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除；
                    2) 结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节(internal adding)；
                    3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节{trailing padding}。
(21)虚基类 为了解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，
            同一个函数名也只有一个映射。这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。     

(22)计算机字符编码   
(23)进程通信和线程通信 http://blog.csdn.net/fly_yr/article/details/50970198   
(24)仿函数(函数对象): 重载了操作符()的类，其对象被称为函数对象，因为它们是行为类似函数的对象，所以称之为仿函数。
(25)lambda表达式  http://blog.csdn.net/fjzpdkf/article/details/50249287     
(26)RTTI    运行时类型信息(Run-Time Type Information)， dynamic_cast：
(27)static_cast与dynamic_cast 
                    Base *P = new Derived();  
                    Derived *pd1 = static_cast<Derived *>(P);      //编译和运行没有问题
                    Derived *pd2 = dynamic_cast<Derived *>(P);     //编译和运行没有问题
                    
                    Base *P = new Base;  
                    Derived *pd3 = static_cast<Derived *>(P);      //编译没有问题，运行可能有问题
                    Derived *pd4 = dynamic_cast<Derived *>(P);     //运行时，pd4=NULL，可以防止可能不合理的从基类指针强制转换为派生类指针
(28)虚函数表与虚指针: 虚函数表属于类，虚指针属于对象。对于单继承来说，一个含有虚函数的类只有一张虚函数表，对于多继承来说，会有多个虚函数表，对应对象有多个虚指针 
(29)多重继承，虚继承的内存布局： http://blog.chinaunix.net/uid-16723279-id-3568748.html    http://www.cnblogs.com/demian/p/6538301.html   
(30)C++并发指南  http://www.cnblogs.com/haippy/p/3284540.html
(31)智能指针：
    出现的背景：一般情况下new会对应delete，但是由于程序员忘记写delete或者在delete语句之前程序出现了异常跳转，导致没有执行delete语句，从而导致内存泄漏
    auto_ptr的问题：
    auto_ptr< string> ps (new string ("I reigned lonely as a cloud.”）;
    auto_ptr<string> vocation; 
    vocaticn = ps;   //当ps和vocation过期时，会释放两次内存导致错误
    
(32) sizeof("hello") = 6,  strlen("hello") = 5; strlen只能用于字符串。

              