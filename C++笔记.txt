(1)volatile   遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 
              当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存.
(2)mutable    被mutable修饰的变量可以在常成员函数中被修改
(3)const_cast 可以去除变量的volatitle属性和const属性
(4)sizeof     在编译时进行运算，与运行时无关
(5)左值       左值一定是可以寻址的，不能寻址的表达式不能作为左值，例如字面值常量
(6)unicode与utf8   Unicode是一种字符集(即字符的集合，国际标准，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储)，UTF-32/ UTF-16/ UTF-8是三种字符编码方案。
              http://blog.jobbole.com/76376/
(7)explicit   指定构造器只能被明确调用，而不能隐式调用( 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 
              1 是个构造器 2 是个默认且隐含的类型转换操作符。 所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 
              这时候编译器就自动调用这个构造器， 创建一个AAA的对象。)
(8)struct与class struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的
                struct可以继承class，同样class也可以继承struct，那么默认的继承访问权限是看子类到底是用的struct还是class。
(9)reinterpret_cast  使任何类型的指针之间都可以互相转换，都不会得到编译错误， 
                    错误的使用reinterpret_cast很容易导致程序的不安全，只有将转换后的类型值转换回到其原始类型，这样才是正确使用reinterpret_cast方式。    

(10)类的定义后为什么要加分号？ 类在C++中被当着一种数据类型，但凡是跟在数据类型后面的不是变量就是函数，如果没有加分号，则会将后面的内容解释成变量或函数，导致出错。 
(11)类中的常成员变量和引用变量必须通过初始化列表来初始化，因为常变量和引用不能被赋值    
(12)类的静态成员变量的初始化问题, C++认为类体中的相关语句是变量的声明而不是定义，一般情况下不允许在类体中指定变量的值
        常静态成员变量(static const): 可在类中初始化，也可在类外初始化
            class A{
                static const int i;
                static const int j = 6;  //这里的右值必须是常量表达式
            };
            const int A::i = 5;     //这里的const不能省略, 不能有static关键字
        普通静态成员变量: 只能放在类外进行
            class B{
                static int i;
            };
            int B::i = 2; 
(13)为什么基类的析构函数是虚函数？ 在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生。
(14)为什么复制构造函数的形参必须是一个引用？ 如果你给它定义的参数，是一个类型，而不是一个类型的引用，会导致无穷递归。 
(15)如何需要"深拷贝",必须显式的定义复制构造函数。
(16)new & operator new & placement new:
    new: 运算符， 申请内存和初始化对象
    operator new: 函数，类似于C语言的malloc，用于分配内存空间，但不会初始化空间，可以被重载
    placement new: 函数，定位放置new, A *p = new(ptr)A  ptr是指定的内存首地址
(17)如何禁止在堆和栈上创建对象？ 参考 http://www.cnblogs.com/vincently/p/4838283.html
    类的对象建立方式:
        静态建立: A a, 静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数
        动态建立: A* ptr=new A 第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。
    禁止在堆上建立对象:  将operator new()设为私有即可
    禁止在栈上建立对象:  编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。
                         如果类的析构函数是私有的或者保护的，则编译器不会在栈空间上为类对象分配内存(无法通过编译)。在堆上创建不会受到禁止
                         因此可以将析构函数设置成保护的，通过new来在堆上创建对象，但是由于析构函数是保护的，无法直接delete，所以需要提供一个共有的函数接口在对象使用完毕后来释放对象
                        更好的做法，是将构造函数和析构函数均设置为protected的，然后提供公有接口来返回对象实例。 
                        
(18)内存池技术
(19)私有成员会被继承吗？  基类的私有成员在派生类中是"不可见"，这种不可见性指派生类的成员函数或者派生类的对象不能直接访问它们，但是却可以间接访问到它们   
(20)结构体对齐问题             
              
              
              
              
              
              